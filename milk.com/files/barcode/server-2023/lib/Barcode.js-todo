// Copyright 1994-2023 the Barcode Server Authors (Dan Bornstein et alia).
// SPDX-License-Identifier: Apache-2.0

/* dispatch to the right form factor UPC/EAN barcode generator,
 * based on the number of digits present and/or requested; pass
 * explicitDigitCount as 0 if you want DWIM-type behavior */
void processUpcEan (char *str, int explicitDigitCount, int shortForm,
          int httpHeader)
{
  char digits[16];
  int digitCount = 0;
  char supDigits[8];
  int supDigitCount = 0;
  char *instr = str;
  char *banner = NULL;
  int supplement = 0;
  int mcheck = 0;
  int vstart = 8;
  Bitmap *barcode;

  if (str == NULL)
  {
    str = "000000000000";
    instr = str;
  }

  while ((digitCount < 15) && (supDigitCount < 7))
  {
    char c = *instr;
    if (((c >= '0') && (c <= '9')) || (c == '?'))
    {
      if (supplement)
      {
        supDigits[supDigitCount] = *instr;
        supDigitCount++;
      }
      else
      {
        digits[digitCount] = *instr;
        digitCount++;
      }
    }
    else if (c == ',')
    {
      supplement = 1;
    }
    else if (c == ':')
    {
      banner = instr + 1;
      break;
    }
    else if (c == '\0')
    {
      break;
    }
    else
    {
      mcheck += ((c == 0x5b) && (instr == str)) |
        ((c == 0x4d) && (instr == (str + 1))) |
        ((c == 0x5d) && (instr == (str + 2)));
    }
    instr++;
  }

  digits[digitCount] = '\0';
  supDigits[supDigitCount] = '\0';

  if (supDigitCount == 0)
  {
    supplement = 0;
  }
  else if ((supDigitCount == 2) || (supDigitCount == 5))
  {
    supplement = upcEanSupplementWidth (supDigits);
  }
  else
  {
    textToXbm ("The entered number is not supported;\n"
           "supplements may only be 2 or 5 digits.",
           httpHeader);
    return;
  }

  if (banner == NULL)
  {
    banner = defaultBannerMsg;
  }
  else if (*banner == '\0')
  {
    banner = NULL;
    vstart = 0;
  }

  switch (digitCount)
  {
    case 7:
    {
      if ((explicitDigitCount != 0) && (explicitDigitCount != 6))
      {
        textToXbm ("The entered number is not supported;\n"
               "Passing 7 digits is only possible for\n"
               "UPC-E barcodes.",
               httpHeader);
        return;
      }
      barcode = makeUpcE (digits, shortForm, vstart, supplement);
      break;
    }
    case 8:
    {
      if (explicitDigitCount == 0)
      {
        if (digits[0] == '0')
        {
          barcode = makeUpcE (digits, shortForm, vstart, supplement);
        }
        else
        {
          barcode = makeEan8 (digits, shortForm, vstart, supplement);
        }
      }
      else if (explicitDigitCount == 6)
      {
        barcode = makeUpcE (digits, shortForm, vstart, supplement);
        if (barcode == NULL)
        {
          textToXbm ("The entered number is not supported;\n"
                 "UPC-E barcodes must start with the\n"
                 "digit 0 or 1.",
                 httpHeader);
          return;
        }
      }
      else if (explicitDigitCount == 8)
      {
        barcode = makeEan8 (digits, shortForm, vstart, supplement);
      }
      else
      {
        textToXbm ("The entered number is not supported;\n"
               "Passing 8 digits is only possible for\n"
               "EAN-8 and UPC-E barcodes.",
               httpHeader);
        return;
      }
      break;
    }
    case 12:
    {
      if ((explicitDigitCount == 0) || (explicitDigitCount == 12))
      {
        barcode = makeUpcA (digits, shortForm, vstart, supplement);
      }
      else if (explicitDigitCount == 6)
      {
        barcode = makeUpcE (digits, shortForm, vstart, supplement);
        if (barcode == NULL)
        {
          textToXbm ("The entered number is not supported;\n"
                 "In order to fit into a UPC-E barcode,\n"
                 "the original number must meet several\n"
                 "restrictions.",
                 httpHeader);
          return;
        }
      }
      else
      {
        textToXbm ("The entered number is not supported;\n"
               "Passing 12 digits is only possible for\n"
               "UPC-A and UPC-E barcodes.",
               httpHeader);
        return;
      }
      break;
    }
    case 13:
    {
      if ((explicitDigitCount != 0)
        && (explicitDigitCount != 12))
      {
        textToXbm ("The entered number is not supported;\n"
               "Passing 13 digits is only possible for\n"
               "EAN-13 barcodes.",
               httpHeader);
        return;
      }
      barcode = makeEan13 (digits, shortForm, vstart, supplement);
      break;
    }
    default:
    {
      textToXbm ("The entered number is not supported;\n"
             "You must supply 7, 8, 12, or 13 digits\n"
             "for the primary UPC/EAN number to encode.",
             httpHeader);
      return;
    }
  }

  if (supplement)
  {
    if (shortForm)
    {
      drawUpcEanSupplementalBars (barcode, supDigits,
                    barcode->width - supplement,
                    vstart, barcode->height - 1, 0);
    }
    else
    {
      drawUpcEanSupplementalBars (barcode, supDigits,
                    barcode->width - supplement,
                    vstart + 1, barcode->height - 4, 1);
    }
  }

  if (banner != NULL)
  {
    bitmapDrawString5x8 (barcode,
               (barcode->width + 1 -
                ((int) strlen (banner) * 5)) / 2,
               0,
               banner);
  }

  if (mcheck == 3)
  {
    bitmapCopyRect (barcode, barcode->width - 5, barcode->height - 56,
            &font5x8, 0, 0, 5, 56);
  }

  bitmapPrintXBM (barcode,
          "the milk.com barcode generator; "
          "http://www.milk.com/barcode/",
          "milk_barcode", httpHeader);

  bitmapFree (barcode);
}




/* ----------------------------------------------------------------------------
 * HTTP form stuff
 */

/* extract and unescape the string between the given pointers (not including
 * the character pointed to by the "to" pointer), into the given buffer;
 * if the string won't fit then it is truncated; the stored result is always
 * null-terminated; this returns NULL if there was a format problem. */
char *formExtractString (char *from, char *to, char *buf, int bufSize)
{
  char *out = buf;

  while ((bufSize > 1) && (from < to))
  {
    char c = *from;
    from++;

    if (c == '=')
    {
      break;
    }
    else if (c == '+')
    {
      c = ' ';
    }
    else if (c == '%')
    {
      char c1 = tolower (from[0]);
      char c2 = tolower (from[1]);
      from += 2;

      if ((c1 >= '0') && (c1 <= '9'))
      {
        c = (c1 - '0') << 4;
      }
      else if ((c1 >= 'a') && (c1 <= 'f'))
      {
        c = (c1 - 'a' + 10) << 4;
      }
      else
      {
        /* bad character in % sequence */
        return NULL;
      }

      if ((c2 >= '0') && (c2 <= '9'))
      {
        c += c2 - '0';
      }
      else if ((c2 >= 'a') && (c2 <= 'f'))
      {
        c += c2 - 'a' + 10;
      }
      else
      {
        /* bad character in % sequence */
        return NULL;
      }
    }

    *out = c;
    out++;
    bufSize--;
  }

  *out = '\0';
  return buf;
}

/* extract the first key/value pair from the given form-encoded string,
 * including doing the requisite unescaping, and return the start of the
 * next key/value pair; keys or values that don't fit in the space provided
 * are truncated; the stored results are always null-terminated; this
 * returns NULL if no data was successfully parsed. */
char *formExtractFirst (char *form, char *key, int keySize,
            char *value, int valueSize)
{
  char *equalsPtr = form;

  /* find the '=' */
  while (*equalsPtr && (*equalsPtr != '='))
  {
    equalsPtr++;
  }

  if (*equalsPtr != '=')
  {
    /* no '='; bad form data/end of form */
    return NULL;
  }

  key = formExtractString (form, equalsPtr, key, keySize);
  if (key == NULL)
  {
    /* format problem */
    return NULL;
  }

  /* find the '&' or the end of the string */
  form = equalsPtr + 1;
  while (*form && (*form != '&'))
  {
    form++;
  }

  value = formExtractString (equalsPtr + 1, form, value, valueSize);
  if (value == NULL)
  {
    /* format problem */
    return NULL;
  }

  if (*form == '&')
  {
    form++;
  }

  return form;
}



/* ----------------------------------------------------------------------------
 * run the show
 */

/* different modes of operation */
typedef enum
{
  MODE_UPCEAN, MODE_UPCEAN_SHORT, MODE_UPCE, MODE_UPCE_SHORT,
  MODE_EAN8, MODE_EAN8_SHORT,
  MODE_TEXT, MODE_PONDER, MODE_CHECK, MODE_PRINT_PASSWORD
}
Mode;

/* all the possible options to the program */
typedef struct
{
  int requirePassword; /* boolean whether to require a password */
  int httpHeader;      /* boolean whether to generate an HTTP reply header */
  Mode mode;           /* mode of operation */
  char *password;      /* password value */
  char *value;         /* value to encode */
}
Options;

/* initialize an options struct */
void initOptions (Options *opts)
{
  opts->requirePassword = 0;
  opts->httpHeader = 0;
  opts->mode = MODE_UPCEAN;
  opts->password = NULL;
  opts->value = NULL;
}

/* interpret a mode string */
int setMode (Options *opts, char *mode)
{
  if (strcmp (mode, "upcean") == 0)
  {
    opts->mode = MODE_UPCEAN;
  }
  else if (strcmp (mode, "upcean-short") == 0)
  {
    opts->mode = MODE_UPCEAN_SHORT;
  }
  else if (strcmp (mode, "upce") == 0)
  {
    opts->mode = MODE_UPCE;
  }
  else if (strcmp (mode, "upce-short") == 0)
  {
    opts->mode = MODE_UPCE_SHORT;
  }
  else if (strcmp (mode, "ean8") == 0)
  {
    opts->mode = MODE_EAN8;
  }
  else if (strcmp (mode, "ean8-short") == 0)
  {
    opts->mode = MODE_EAN8_SHORT;
  }
  else if (strcmp (mode, "text") == 0)
  {
    opts->mode = MODE_TEXT;
  }
  else
  {
    return 0;
  }

  return 1;
}

/* set options from an http form submission string */
void setOptionsFromForm (Options *opts, char *form)
{
  char key[100];
  char value[2000];

  while (*form)
  {
    form = formExtractFirst (form, key, 100, value, 2000);
    if (form == NULL)
    {
      break;
    }

    if (strcmp (key, "password") == 0)
    {
      opts->password = strdup (value);
    }
    else if (strcmp (key, "value") == 0)
    {
      opts->value = strdup (value);
    }
    else if (strcmp (key, "mode") == 0)
    {
      setMode (opts, value);
    }
  }
}

/* set options from argv */
void setOptionsFromArgv (Options *opts, int argc, char *argv[])
{
  int parseForm = 0;

  /* skip the name of the executable */
  argv++;
  argc--;

  while (argc > 0)
  {
    if (strncmp (*argv, "--", 2) != 0)
    {
      break;
    }

    if (strcmp (*argv, "--require-password") == 0)
    {
      opts->requirePassword = 1;
    }
    else if (strcmp (*argv, "--http-header") == 0)
    {
      opts->httpHeader = 1;
    }
    else if (strncmp (*argv, "--mode=", 7) == 0)
    {
      char *modeStr = (*argv) + 7;
      setMode (opts, modeStr);
    }
    else if (strcmp (*argv, "--check") == 0)
    {
      opts->mode = MODE_CHECK;
    }
    else if (strcmp (*argv, "--print-password") == 0)
    {
      opts->mode = MODE_PRINT_PASSWORD;
    }
    else if (strcmp (*argv, "--form-data") == 0)
    {
      parseForm = 1;
    }
    else
    {
      fprintf (stderr, "unrecognized option: %s\n", *argv);
    }

    argc--;
    argv++;
  }

  if (argc != 0)
  {
    if (parseForm)
    {
      setOptionsFromForm (opts, *argv);
    }
    else
    {
      opts->value = strdup (*argv);
    }
  }

  if (opts->value != NULL)
  {
    char *value = opts->value;
    if (*value == ':')
    {
      char *col2 = strchr (value + 1, ':');
      if (col2 != NULL)
      {
        int amt = col2 - value;
        char *mstr = malloc (amt);
        amt--;
        memcpy (mstr, value + 1, amt);
        mstr[amt] = '\0';
        if (setMode (opts, mstr))
        {
          char *newv = strdup (col2 + 1);
          free (opts->value);
          opts->value = newv;
        }
        free (mstr);
      }
    }
  }
}

int main (int argc, char *argv[])
{
  Options opts;
  initOptions (&opts);
  setOptionsFromArgv (&opts, argc, argv);

  switch (opts.mode)
  {
    case MODE_UPCEAN:
    {
      processUpcEan (opts.value, 0, 0, opts.httpHeader);
      break;
    }
    case MODE_UPCEAN_SHORT:
    {
      processUpcEan (opts.value, 0, 1, opts.httpHeader);
      break;
    }
    case MODE_UPCE:
    {
      processUpcEan (opts.value, 6, 0, opts.httpHeader);
      break;
    }
    case MODE_UPCE_SHORT:
    {
      processUpcEan (opts.value, 6, 1, opts.httpHeader);
      break;
    }
    case MODE_EAN8:
    {
      processUpcEan (opts.value, 8, 0, opts.httpHeader);
      break;
    }
    case MODE_EAN8_SHORT:
    {
      processUpcEan (opts.value, 8, 1, opts.httpHeader);
      break;
    }
    case MODE_TEXT:
    {
      if (opts.value == NULL)
      {
        opts.value = "Enjoy milk's many splendors\nat www.milk.com!";
      }
      textToXbm (opts.value, opts.httpHeader);
      break;
    }
  }

  exit (0);
}
